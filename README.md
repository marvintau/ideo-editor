# TODO:       
   
**revise the calculation of intersection**

1. UI便利性 [done]
   * 点击汉字的时候，对应的spec条目出现 [done]
   * 对spec和某种更简单的语言实现双向翻译 [done]
   * 在线编辑 [done]
   * 代码高亮 [done]
   * 提交代码 [done]
    
2. 字拓扑结构的约束条件

   * 实现一个变量列表，变量列表的条目内包含变量名称、描述、range和默认值 [done]
   * 初始化对象时，变量列表将作为各层次对象的一个属性（即加入到CurveStructureBase中）[done]
   * prog读取变量表初始化其中的值[done]
   * 约束列表，列表内的条目包含比较运算符，getter和标的值。getter应该对应prog中的setter[**ongoing**]
       * 获得cross [done]
       * 算术比较variable [done]
       * 获取笔画总长度 [done]
       * 获取某个笔画部件的长度 [done]
       
3. 自动在boundary内寻找所有参数组合，以及rect/centroid结果 [*next*]

4. RadicalSet: 组字方法 [*next*]

# 自动化汉字设计

## 提出模型的背景

至今为止，我们对计算机内存储的汉字字体，也包括其它各种文字的字体，都是作为以矢量图形为主的图像对待的，而较少研究笔画的内在结构。拉丁基础的西文字体的字母表相对较小，其工作量主要在于设计每个字母符号及解决kerning的问题。但是对于字母表庞大的中文字体来说，这种方法相当于绘制几万张图画，非常不容易。

而且，对于用于视觉信息交流的中文字体来说，它身上兼具着信息和情感传达的双重任务，因此它既要足够庞大以至于能够覆盖尽可能多的字符，又要在日常交流和作为标志和指示的字符集中体现出足够的设计美感。到目前为止我们没能找到系统化的解决方法，而尤其依赖设计师的审美和他们极为艰苦的工作。

但事实上我们应该认识到，汉字的构成极富规律，而这样的规律没有体现在汉字设计的活动中。与此同时在中国，书法和艺术字对汉字设计的影响实在太大，使得人们容易认为汉字设计更像是一种创意艺术，而非在各种约束环境下的设计工程。

## 我们实际上是如何理解汉字的

单个汉字作为兼具图像、象形文字和书写符号的身份，主要包含两个层次的信息。第一层是基本的能够被识别的信息，第二层是美学的信息。

古代限于书写工具的限制，如甲骨文和金文等，很难写出整齐和均匀的文字。彼时的文字对结构几乎没有要求，只要在这个区域内有足够的要素即能识别。比如“哭”字，其讲述的故事是写作“大”字的人跪在地上大声的呼号，两个“口”字代表其呼喊的声音很大。不同的异体字里，这两个口有的出现在这个“人”的上方，有的出现在左右两侧。我们按照这种方法，即可认识各种异体字。(更多关于字源的资料参考[这里](http://www.vividict.com/WordInfo.aspx?id=704))

隶书以及后来的楷书普及的时候，汉字笔画被大大简化，造成了很多本来差异很大的汉字变为形似字，比如 “[士](http://www.vividict.com/WordInfo.aspx?id=3625)” 和 “[土](http://www.vividict.com/WordInfo.aspx?id=2176)” 。汉字由此进一步符号化，而减少了它作为图像指示的原意。结构的变化，或者某些笔画部件的代替，比如中文繁体的“總”与日文汉字的“総”，就会给阅读和识别带来较大差异。因此在今天，我们认识汉字主要依据汉字笔画的拓扑结构，或者我们更常说的“**间架结构**”。

尽管我们不会像欣赏画作一样欣赏汉字，但是汉字仍然具备重要的美学信息。即使一个没有书法基础的人，甚至是一个不使用汉字的人，也能辨认出谁写的好看，谁写的不好看，谁写的更好看。那么只要存在这种比较和程度的存在，汉字设计就有被量化和自动化的可能。

汉字的美学又分为两种，一种和间架结构有关。我们可以以两种方式来对待汉字的间架结构。一种是将汉字的笔画作为无宽度的几何曲线，在这种角度下主要考量的是这样一套曲线将如何分割这个汉字所占用的白空间。另一种是将笔画假象为一种匀质的材料，而汉字则会变成一个物体，然后考量这个物体是否在各种条件下满足平衡性。除了间架结构外，我们也考察笔画的形状，即考虑笔画如何填充字面的白空间，譬如楷书中的“藏锋”和“露锋”起笔，横划的“短横”和“横担”，竖画的“悬针”和“垂露”等等，以及装饰性的部分，比如衬线等。

##好的



首先我们知道，笔画最基本的参数是构成笔画的线段的**长度**、**角度**以及**笔画之间的位置**。在
最高层次表现出的字是否好看是由构成这个字的所有笔画的长度角度及位置决定的。可以应用于这些参数的操
作包括，长度变化、角度变化和位置变化。也就是说这三个参数是最基本的参数。

在这个基础上我们需要对部首做出描述。当笔画构成部首的时候产生了一些新的信息，包括这个部首的位置、
外框，笔画密集区域框（这个需要更精确地定义）和outlier框。它们不是基本的参数，而是由底层参数计算所得的。同时
对它们操作包含位置移动，笔画密集区域框的移动。
    
接下来我们可以来定义一些规则：
1. 整个汉字的外框、笔画密集区域框应当居中且基本同心，至少同轴
2. 同一偏旁部首的互补部分的外框、笔画密集区域框应当相同，且互相贴近
3. 部首的形态应当与其所在结构位置有关

# 描述汉字的数据结构

基于上述的描述，我们设计以下层级结构，每个层级通过其子层级构成，并且允许不同的操作。

1. Seg
   线段由anchor, angle与length构成，同时记录spec
   允许的修改操作包括：
       根据spec进行旋转，拉伸和平移
   其他的参数包括：
       获取bbox
   其他的一般方法包括：
       copy，绘图

2. Curve
   Curve由Seg列表构成
   允许的操作包括：
       根据spec对Seg进行操作(对整个曲线进行旋转、拉伸和平移)
   其它的参数包括：
       获取bbox
       获取依据ratio得到的一点：at
   其他的一般方法：
       copy，绘图

3. CompoundCurve
   由Curve列表构成，即我们一般所指的“笔画”。
   允许的操作包括：
       根据spec对Curve进行操作（对整个曲线进行拉伸，对曲线中的一部分进行旋转、拉伸）
   其他参数包括：
       获取bbox
       获取依据ith curve与ratio得到的点: at

4. CrossedStrokeSet
   由CompoundCurve列表构成，代表一系列笔画部件，即这些部件均通过笔画的交汇、相接
   或固定的相对位置构成来描述。近似与部首或者独体字（中的一部分）
   允许的操作包括：
       按spec移动笔画（只在初始化进行一次）
   其他参数包括
       获取bbox
       ？获取依据ith compound curve与ratio得到的点：at

    **需要注意的是，CrossedStrokeSet的spec必需指定一些方法，使得它能够适应不同的偏
    旁位置、高度和宽度的微小调整，以及其它形状变化的需求。**

5. AlignedStrokeSet
   由crossedStrokeSet构成。它代表的是通过基础部件对齐和组合的方式构成的笔画集合，近
   似于我们所说的部首，当然，也包括最终的完整汉字
   允许的操作包括：
       根据spec对AlignedStrokeSet进行操作（按align的方法进行移动）
   其他参数包括
       获取bbox
   
