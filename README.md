# TODO:

1. UI便利性 [done]
   * 点击汉字的时候，对应的spec条目出现 [done]
   * 对spec和某种更简单的语言实现双向翻译 [done]
   * 在线编辑 [done]
   * 代码高亮 [done]
   * 提交代码 [done]
   * 将文本代码保存至服务器并persistent store [done]
   * 可以搞出变量的拖拽条 [done]
       
    
2. 字拓扑结构的约束条件

   * 实现一个变量列表，变量列表的条目内包含变量名称、描述、range和默认值 [done]
   * 初始化对象时，变量列表将作为各层次对象的一个属性（即加入到CurveStructureBase中）[done]
   * prog读取变量表初始化其中的值[done]
   * 约束列表，列表内的条目包含比较运算符，getter和标的值。getter应该对应prog中的setter[done]
       * 获得cross [done]
       * 算术比较variable [done]
       * 获取笔画总长度 [done]
       * 获取某个笔画部件的长度 [done]
       
3. 自动在boundary内寻找所有参数组合，以及rect/centroid结果 [**ongoing**]
   * centroid方法[done]
   * Voronoi笔画分割方法[done]
   * 获取canvas上的点阵信息[done]
   * 统计同种颜色pixel数[**ongoing**]
   
       
     

4. RadicalSet: 组字方法 [*next*]

##如何使用参数控制字体
起初我们并不能使用参数控制一整套字体，而只能控制一个个笔画的形状。想通过笔画的形状来决定一个字的形状，并且最终找到不依赖具体某个字的形状，却能够定义一套字符集风格的参数。因此在可以使用参数控制字体形态之前，我们先要能够恰当地定义这个参数，而定义参数的过程，就是对特征量化的过程。

> 汉字笔画的特征较容易量化，譬如黑体字的笔画是方的，宋体字笔画两端有衬线和顿笔的形状，
> 楷体则更容易用笔锋的运动来描述，而此处讨论的是决定汉字字形的另一方面，也就是**间架结构**的特征。
> 

在我们的定义之下，笔画是一个个线段的集合，而字符是通过笔画的**长度**、**旋转角度**及笔画之间的**比例**、**交会位置**决定的。这个定义帮我们摆脱了具体的坐标值和对位置、大小的依赖。

当笔画有了构成，比如最基本的汉字，如“二”和“十”，我们就获得了几个基本的可以量化的特征，包括

* 汉字的几何重心
* 汉字笔画如何划分空间 (Voronoi Diagram) (Morphological)
* 汉字的**最重区域**

最重区域比较难定义，一个比较模糊的描述是一个字当中笔画密度相对比较大的部分。我们需要通过调节这个最重区域的大小，来控制一个字看起来的胖瘦。事实上我们引用了很多模糊的描述，比如什么叫做**笔画密度**，以及什么是**胖瘦**。首先，不同字的笔画数量不同，自然导致疏密程度不一样，比如“三”和“鷹”的笔画疏密程度就不可能一样。

### 基于Kernel的方法
基于在笔画上的点进行采样，然后统计什么尺寸的框 (kernel) 可以在图像区域内获得最大和最小的采样点。这个方法的问题是，无论是框的尺寸选择还是移动的过程，都需要选择一个合适的step，否则会造成极大的计算量。与此同时另一个问题是，这个方法有可能会产生很多框，因为完全存在多个框有同样的最大采样点数量的可能性。

总体来说這種方法基于kernel，是一種點陣圖像處理的思路，這種思路的優點是所獲得到的總是一個矩形，但是不足的地方是這個區域的位置可能和質心的位置很遠，這個還不知道怎麼解釋。

### 基于Convex Hull的方法
第二種是將所有的點按照到質心的距離排序，然後逐個求convex hull看哪個cunvex hull囊括了半數的點，或者看占總面積一半的convex hull囊括了百分之多少的點。這個更像是一個幾何學的算法，但結果是我們會得到一個不規則的圖形。不過不規則圖形也有自己的好處，即我們可以研究它的穩定性，而不像本來不穩定的字，因為採用kernel的方法而無法研究其穩定性。

### 笔画疏密程度确认



##好



首先我们知道，笔画最基本的参数是构成笔画的线段的**长度**、**角度**以及**笔画之间的位置**。在
最高层次表现出的字是否好看是由构成这个字的所有笔画的长度角度及位置决定的。可以应用于这些参数的操
作包括，长度变化、角度变化和位置变化。也就是说这三个参数是最基本的参数。

在这个基础上我们需要对部首做出描述。当笔画构成部首的时候产生了一些新的信息，包括这个部首的位置、
外框，笔画密集区域框（这个需要更精确地定义）和outlier框。它们不是基本的参数，而是由底层参数计算所得的。同时
对它们操作包含位置移动，笔画密集区域框的移动。
    
接下来我们可以来定义一些规则：

1. 整个汉字的外框、笔画密集区域框应当居中且基本同心，至少同轴
2. 同一偏旁部首的互补部分的外框、笔画密集区域框应当相同，且互相贴近
3. 部首的形态应当与其所在结构位置有关

# 描述汉字的数据结构

基于上述的描述，我们设计以下层级结构，每个层级通过其子层级构成，并且允许不同的操作。

1. Seg
   线段由anchor, angle与length构成，同时记录spec
   允许的修改操作包括：
       根据spec进行旋转，拉伸和平移
   其他的参数包括：
       获取bbox
   其他的一般方法包括：
       copy，绘图

2. Curve
   Curve由Seg列表构成
   允许的操作包括：
       根据spec对Seg进行操作(对整个曲线进行旋转、拉伸和平移)
   其它的参数包括：
       获取bbox
       获取依据ratio得到的一点：at
   其他的一般方法：
       copy，绘图

3. CompoundCurve
   由Curve列表构成，即我们一般所指的“笔画”。
   允许的操作包括：
       根据spec对Curve进行操作（对整个曲线进行拉伸，对曲线中的一部分进行旋转、拉伸）
   其他参数包括：
       获取bbox
       获取依据ith curve与ratio得到的点: at

4. CrossedStrokeSet
   由CompoundCurve列表构成，代表一系列笔画部件，即这些部件均通过笔画的交汇、相接
   或固定的相对位置构成来描述。近似与部首或者独体字（中的一部分）
   允许的操作包括：
       按spec移动笔画（只在初始化进行一次）
   其他参数包括
       获取bbox
       ？获取依据ith compound curve与ratio得到的点：at

    **需要注意的是，CrossedStrokeSet的spec必需指定一些方法，使得它能够适应不同的偏
    旁位置、高度和宽度的微小调整，以及其它形状变化的需求。**

5. AlignedStrokeSet
   由crossedStrokeSet构成。它代表的是通过基础部件对齐和组合的方式构成的笔画集合，近
   似于我们所说的部首，当然，也包括最终的完整汉字
   允许的操作包括：
       根据spec对AlignedStrokeSet进行操作（按align的方法进行移动）
   其他参数包括
       获取bbox
   
