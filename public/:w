
/**
 * 描述笔划的类:Stroke
 */

class Stroke {

    /**
     * 构造笔划的方法: 从JSON读入segs列表, 并依据它初始化点集
     * segs代表了由连续线段构成的曲线, 每一个线段用这个线段的
     * 起始端点到结束端点的角度和长度来描述. 所以segs看起来像
     * 是这样 :
     *
     * [{len:1, ang:30}, {len:2, ang:60}, ...]
     *
     * 你会注意到这个曲线是位置无关的, 它至少需要一个起始点的
     * 坐标才能转换为点集.
     * 
     * 这种数据结构用来描述一个曲线的好处是当需要对曲线进行旋
     * 转和放大缩小操作的时候, 只需要加法和乘法而不需要三角函
     * 数, 所以很快. 但缺点是进行横向或纵向拉伸时非常别扭 (当
     * 然这正是点集的优势).因此在处理JSON的时候, 会先解决掉所
     * 有的旋转和缩放操作, 在转换为点集之后再进行横纵向拉伸.
     *
     * 此处构造Stroke对象事例时, 应当已经进行完旋转拉伸操作, 
     * 准备进入和点集相关的操作了.
     */
    constructor(segs){
        this.segs = segs;
        this.init_points(segs);
    }

    /**
     * 初始化点集:
     * 计算出曲线上每个点的坐标时, 还有一个叫做 r的列表. 这个
     * 表记录了从起始端点到第 i个线段的末端点的长度, 与整个曲
     * 线长度的比例. 我们需要这个列表, 是因为我们描述笔划的时
     * 候, 是通过曲线上一个点 p, 满足曲线上从起始端点到 p的长
     * 度与曲线总长度之比为r'的条件, 来计算两个笔划相交在什么
     * 位置的. 因此我们只要通过两个曲线上的r'就可以最终计算出
     * 坐标了.
     *
     * 需要注意的是, 这个 r列表不会因为points的变化而变化, 因
     * 为拉伸及横纵向缩放会改变曲线上每个线段的长度, 但是不会
     * 改变线段长度的比例. 所以 r只需要计算一次就可以.
     */

    init_points(segs){

        this.points = [new Vec(0, 0)];

        for(let seg of segs){
            var last = this.points[this.points.length-1],
                nvec = new Vec(Math.cos(2*Math.PI * seg.ang / 360), Math.sin(2*Math.PI * seg.ang / 360)),
                mult = new Vec(seg.len, seg.len);
            this.points.push(last.add(nvec.mult(mult)));
        }

        this.r = [0];

        for(let i = 0; i < this.points.length-1; i++){
            this.r.push(this.r[i] + segs[i].len);
        }
        for(let i = 0; i < this.r.length; i++){
            this.r[i] /= this.r[this.r.length-1];
        }
 
    }

    /**
     *  Find point over stroke curve with ratio, similar to finding
     *  t over a bezier curve;
     */
    getPointAt(ratio){

        var point;

        if(ratio >= 1){
            var last = this.points.length - 1,
                seg_ratio = (this.r[last]-ratio)/(this.r[last]-this.r[last-1]);
            point = this.points[last].lerp(this.points[last-1], seg_ratio);
            return point;
        }
        if(ratio < 0){
            var seg_ratio = (this.r[1]-ratio)/(this.r[1]-this.r[0]);
            point = this.points[1].lerp(this.points[0], seg_ratio);
            return point;
        }

        for(var i in this.r){
            if(ratio < this.r[i]){

                var seg_ratio = (ratio-this.r[i-1])/(this.r[i]-this.r[i-1]);
                return this.points[i-1].lerp(this.points[i], seg_ratio);
            }
        }

    }

    trans(vec){
        for(let i=0; i < this.points.length; i++){
            this.points[i].addi(vec);
        }
    }

    scale(ratio){
        for(let i=0; i < this.points.length; i++){
            this.points[i].multi(ratio);
        }
    }

    box(){
        var box = new Box(new Vec(0, 0), new Vec(0, 0));
        for(let p of this.points){
            box.lt.x = Math.min(box.lt.x, p.x);
            box.lt.y = Math.min(box.lt.y, p.y);
            box.rb.x = Math.max(box.rb.x, p.x);
            box.rb.y = Math.max(box.rb.y, p.y);
        }
        return box;
    }

    resize(ratio){
        for(let i in this.points){
            this.points[i].mult(ratio);
        }
    }

    draw(ctx){
        ctx.beginPath()
        this.points[0].move(ctx);
        for(let point of this.points) point.line(ctx);
        ctx.stroke();
    }

    copy(){
        var new_stroke = new Stroke(JSON.parse(JSON.stringify(this.segs)));
        new_stroke.points = this.points.map(p=>p.copy());
        new_stroke.r = this.r;
        return new_stroke;
    }
}


